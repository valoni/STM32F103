This folder contains the LWIP TCP/IP stack code base V1.4.1 (Stable) for use with .NET Micro framework OS ports.

The previous attempts to run LWIP in a pseudo threaded environment alongside the CLR has proven to be unreliable. There are several issues that occur, not the least of which are modifications to the core LWIP to make it run at all, which makes integrating updates more difficult. Fundamentally the problem comes in how the stack assumes it owns the single thread of execution in a single threaded port. This behavior, among other things, leads to the various timers counting down much faster than they should (on the level of orders of magnitude too fast). This results in failures in the stack that can appear with many different symptoms. For example, if the stack is processing TCP/IP packets with a certain TTL and thee the stack's timers are all running down much too fast the system thinks the TTL has expired already, causing resends or broken connections.

The actual symptoms of the issues will vary depending on the exact details of the application and specific timer(s) involved. On rare occasions it can lead to deadlocks. One of the easiest cases of issues to observe is where DHCP leases were running down in the stack causing the stack to make DHCP requests much faster than it should (On at least one device tested this was every 17 seconds a new request came out and about every minute a renewal. This results in the network coming down and then back up as the new address is provided to the system. If the .NET Micro Framework application isn't written to handle this, then it will fail. If the app is designed to handle the possibility of network failures and outages then it will continue to function but overall performance will suffer. 

Fixing the individual symptoms at various points in the stack would leave the Micro Framework with what amounts to a significant fork of the LWIP stack and no guarantees we'd actually get them all fixed. ( Our early attempts showed that fixing the timers issue in one place actually exposed race conditions and deadlocks in others ). Thus we stepped back to re-think the problem and re-assess the facts. In the end we concluded that to leverage LWIP in the .NET Micro Framework in a manner that both were designed to support we needed to run the stack on a multithreaded OS with the CLR on one thread and the stack and any support it needed on additional threads. The CLR is designed where an OS or threads aren't required but can be, and in several real cases has been, implemented on top of an OS or thread scheduler. Thus we aren't inventing something new for the core framework. Instead we are changing the requirements when using the LWIP stack.

As it turns out, since the time of the original networking integration with NETMF ARM has released the CMSIS-RTOS API specification for multi-threaded OS support on ARM Cortex-M
microcontrollers. Note that the term OS for this level of functionality is potentially confusing depending on what assumptions you make about what an "OS" is. In this context it is principally a library to provide pre-emptive multi-threaded programming with a few basic synchronization primitives. CMSIS-RTOS isn't an implementation, it's an API specification for the interface between an application and the OS kernel libraries. Along with the API spec, ARM released CMSIS-RTX as an implementation of the spec under an Open Source license. The foot print requirements are extremely small, in the neighborhood of 5-6KB. Thus, this copy of LWIP integration into the .NET Micro framework was born. The intent is to leverage an actual underlying minimal OS ( hidden from LWIP via the sys_arcxxx api porting layer). For ARM we provide a CMSIS-RTX port, for Windows we provide a Win32 port, other CPUs can use FREE-RTOS, uC/OS II, or any other available libraries for their targets with the CMSIS-RTX implementation serving as a guide.

Using a multi threaded OS for the stack doesn't mean that any other part of the framework requires an OS. If you don't need the stack you don't need an OS. If you have already created system specific workarounds or fixes for the previous stack implementation you can continue using that. Going forward however, the only supported approach for using the LWIP stack with the .NET Micro Framework is to use an OS. That is, while the old version is still present and unchanged, it is considered deprecated. There will be no further development of that code base and we intend to completely remove it in the next major release. While the OS does increase the footprint size a bit we believe that there are other areas of optimization where we can pull out redundant or mostly redundant code to gain that back. (How many variations of vfprintf and friends do we really need? [Hint: The answer is smaller than the number of implementations we currently have! ])

As means of rapidly developing and testing the stack with the CLR in this fashion we are adding a raw WIN32 port of NETMF that, like the emulator runs on Win32. Unlike the standard emulator though this port does not implement the HAL/PAL layers in managed code (C#) using the windows network stack. Instead it remains in native code like a real device with an OS. Thus we can build the LWIP stack, test and debug it without needing to go through a JTAG Debug/flash program cycle. 